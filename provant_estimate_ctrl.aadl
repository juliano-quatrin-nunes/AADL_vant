package EstimateAndCtrl

public

	with SEI; -- if use MIPS parameters
	with interSystemCom;

	-- PROCESSADOR
	
	processor Jetson
		features
			ISC_bus_interface: requires bus access interSystemCom::communicationInterfaceBus.impl;
	end Jetson;

	processor implementation Jetson.impl
		properties
			Scheduling_Protocol => (EDF);
			Preemptive_Scheduler => true;
			SEI::MIPSCapacity => 1.0 MIPS; -- must be used if EDF
	end Jetson.impl;

	-- BARRAMENTOS

	bus ISC_bus
	end ISC_bus;

	bus implementation ISC_bus.cpu_bus_access
	end ISC_bus.cpu_bus_access;

	bus ISC_interface_bus_access extends ISC_bus
	end ISC_interface_bus_access;
	
	bus ISC
	end ISC;

	bus implementation ISC.impl
	end ISC.impl;
	

	-- DEVICES
	
	device hp_sensors
		features
			hp_data: out data port hp_data.impl;
		flows
			F_SRC: flow source hp_data {latency => 1ms .. 1ms;};
	end hp_sensors;

	device implementation hp_sensors.impl
	end hp_sensors.impl;
	
	device ISC_Interface
		features
			isc_data_in: in data port;
			ISC_bus_interface: requires bus access interSystemCom::communicationInterfaceBus.impl;
			isc_data_out: out data port;
		flows
			F_SNK: flow sink isc_data_in {latency => 600us .. 600us;};
	end ISC_Interface;

	device implementation ISC_Interface.impl
	end ISC_Interface.impl;

	-- SYSTEMS

	system EstimateAndCtrl
		features
			ISC: requires bus access interSystemCom::communicationInterfaceBus.impl;

	end EstimateAndCtrl;

	system implementation EstimateAndCtrl.impl
		subcomponents
			main: process main.impl;
			hp_sensors: device hp_sensors.impl;
			cpu: processor Jetson.impl;
			ISC_Interface: device ISC_Interface.impl;

		connections
			C1: port hp_sensors.hp_data -> main.hp_data_in;
			C2: port main.isc_data_out -> ISC_Interface.isc_data_in;
			C3: bus access ISC_Interface.ISC_bus_interface <-> ISC;
			C4: bus access cpu.ISC_bus_interface <-> ISC;
			C5: port ISC_Interface.isc_data_out -> main.isc_data_in;
	
		flows	
	    on_end_to_end: end to end flow hp_sensors.F_SRC -> C1 -> 
	   								  main.F1 -> C2 ->
	   								  ISC_Interface.F_SNK {latency => 12ms .. 12ms;};
	   								  
--		on_end_to_end: end to end flow hp_sensors.on_flow_src -> 
--									   hp_sensors_conn_main -> 
--									   main.state_estimator.state_estimator_new_flow_spec ->
--									   auto_ctrl.read_state_vec ->
--									   ISC_gatekeeper_task.ISC_gatekeeper_task ->
--									   isc_device_conn_main -> 
--									   ISC_Interface.on_flow_snk 
--									   {latency => 12ms .. 12ms;};
		properties
			Actual_Processor_Binding => (reference (cpu)) applies to main;

	end EstimateAndCtrl.impl;

	-- PROCESSOS

	data hp_data
	end hp_data;

	data implementation hp_data.impl
	end hp_data.impl;

	process main
		features
			hp_data_in: in data port hp_data.impl;

			isc_data_out: out data port;
			isc_data_in: in data port;
		flows
			F1: flow path hp_data_in -> isc_data_out {latency => 10ms .. 10ms;};
			
	end main;

	process implementation main.impl
		subcomponents
			state_estimator: thread state_estimator.impl;
			auto_ctrl: thread auto_ctrl.impl;
			ref_ctrl: thread ref_ctrl.impl;
			data_rec: thread data_recorder.impl;
			network_gatekeeper: thread network_gatekeeper.impl;
			state_machine: thread state_machine.impl;
		connections
			C1: port hp_data_in -> state_estimator.hp_data_in;
			C2: port data_rec.data_out -> state_estimator.read_data_rec;
			C3: port data_rec.data_out -> auto_ctrl.read_data_rec;
			C4: port data_rec.data_out -> ref_ctrl.read_data_rec;
			C5: port state_estimator.send_state_vec -> auto_ctrl.read_state_vec;
			C6: port state_estimator.send_state_vec -> ref_ctrl.read_state_vec;
			C7: port ref_ctrl.send_ref_signal -> auto_ctrl.ref_signal;
			C8: port network_gatekeeper.isc_data_out -> isc_data_out;
			C9: port network_gatekeeper.isc_send_data -> state_estimator.read_general_sensors;
			C10: port hp_data_in -> data_rec.hp_data_in;
			C11: port auto_ctrl.send_ctrl_inputs -> network_gatekeeper.isc_read_data;
			C12: port network_gatekeeper.isc_send_data -> ref_ctrl.read_active_ctrl;
			C13: port isc_data_in -> network_gatekeeper.isc_data_in;
			C14: port network_gatekeeper.isc_send_data -> state_machine.read_state_trans;
			C15: port state_machine.send_state_trans -> network_gatekeeper.isc_read_data;
		flows
			--F1: flow path hp_data_in -> isc_data_out{latency => 10ms .. 10ms;};
			F1: flow path hp_data_in -> C1 ->
						  state_estimator.F1 -> C5 ->
			              auto_ctrl.F1 -> C11 ->
			              network_gatekeeper.F1 -> C8 -> isc_data_out
			              {latency => 10ms .. 10ms;};
		
			
			
		modes
			ReadSensors: mode;
			StateEstimation: mode;
			RefFrameGen: mode;
			ActuationCtrlCmd: mode;
			main_impl_new_transition: ReadSensors -[state_estimator.hp_data_in, state_estimator.read_data_rec,
				state_estimator.read_general_sensors]-> StateEstimation;
			main_impl_new_transition2: StateEstimation -[ref_ctrl.read_active_ctrl, ref_ctrl.read_data_rec,
				ref_ctrl.read_state_vec]-> RefFrameGen;
			main_impl_new_transition3: RefFrameGen -[auto_ctrl.read_data_rec, auto_ctrl.read_state_vec,
				auto_ctrl.ref_signal]-> ActuationCtrlCmd;
			main_impl_new_transition4: ActuationCtrlCmd -[isc_data_out]-> ReadSensors;
			Unconfigured: initial mode;
			Initializing: mode;
			PreFlight: mode;
			Standby: mode;
			Diagnostics: mode;
			Manual: mode;
			ShuttingDown: mode;
			Recovery: mode;

			T1: Unconfigured -[state_machine.read_state_trans]-> Initializing;
			T2: Initializing -[state_machine.read_state_trans]-> PreFlight;
			T3: PreFlight -[state_machine.read_state_trans]-> Standby;
			T4: Standby -[state_machine.read_state_trans]-> Manual;
			T5: Standby -[state_machine.read_state_trans]-> ReadSensors;
			T6: Standby -[state_machine.read_state_trans]-> Diagnostics;
			T7: ReadSensors -[state_machine.read_state_trans]-> ShuttingDown;
			T8: Manual -[state_machine.read_state_trans]-> ShuttingDown;
			T9: Standby -[state_machine.read_state_trans]-> ShuttingDown;
			T10: ReadSensors -[state_machine.read_state_trans]-> Recovery;
			T11: Manual -[state_machine.read_state_trans]-> Recovery;
			T12: Standby -[state_machine.read_state_trans]-> Recovery;
			T13: Diagnostics -[state_machine.read_state_trans]-> PreFlight;
	end main.impl;

	-- THREADS
	-- Preciso colocar o flow na implementação tbm, caso contrário o Osate não reconhece o flow para análise.
	thread state_estimator
		features
			hp_data_in: in data port;
			read_data_rec: in data port;
			send_state_vec: out data port;
			read_general_sensors: in data port;
		flows
			F1: flow path hp_data_in -> send_state_vec {latency => 3ms .. 3ms;};
			F2: flow path read_general_sensors -> send_state_vec {latency => 3ms .. 3ms;};
			F3: flow path read_data_rec -> send_state_vec {latency => 3ms .. 3ms;};
	end state_estimator;

	thread implementation state_estimator.impl
		flows
			F1: flow path hp_data_in -> send_state_vec {latency => 3ms .. 3ms;};
			F2: flow path read_general_sensors -> send_state_vec {latency => 3ms .. 3ms;};
			F3: flow path read_data_rec -> send_state_vec {latency => 3ms .. 3ms;};
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 1ms .. 2ms;
			Deadline => 6ms;
			Period => 6ms;
			Priority => 1;
	end state_estimator.impl;

	thread auto_ctrl
		features
			read_data_rec: in data port;
			read_state_vec: in data port;
			send_ctrl_inputs: out data port;
			ref_signal: in data port;
		flows
			F1: flow path read_state_vec -> send_ctrl_inputs {latency => 6ms .. 6ms;};
			F2: flow path ref_signal -> send_ctrl_inputs {latency => 6ms .. 6ms;};
			F3: flow path read_data_rec -> send_ctrl_inputs {latency => 6ms .. 6ms;};
	end auto_ctrl;

	thread implementation auto_ctrl.impl
		flows
			F1: flow path read_state_vec -> send_ctrl_inputs {latency => 6ms .. 6ms;};
			F2: flow path ref_signal -> send_ctrl_inputs {latency => 6ms .. 6ms;};
			F3: flow path read_data_rec -> send_ctrl_inputs {latency => 6ms .. 6ms;};
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 3ms .. 4ms;
			Deadline => 12ms;
			Period => 12ms;
			Priority => 2;
	end auto_ctrl.impl;

	thread ref_ctrl
		features
			read_data_rec: in data port;
			read_state_vec: in data port;
			read_active_ctrl: in data port;
			send_ref_signal: out data port;
		flows
			F1: flow path read_state_vec -> send_ref_signal {latency => 1ms .. 1ms;};
			F2: flow path read_data_rec -> send_ref_signal {latency => 1ms .. 1ms;};
			F3: flow path read_active_ctrl -> send_ref_signal {latency => 1ms .. 1ms;};
	end ref_ctrl;

	thread implementation ref_ctrl.impl
		flows
			F1: flow path read_state_vec -> send_ref_signal {latency => 1ms .. 1ms;};
			F2: flow path read_data_rec -> send_ref_signal {latency => 1ms .. 1ms;};
			F3: flow path read_active_ctrl -> send_ref_signal {latency => 1ms .. 1ms;};
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 1ms .. 1ms;
			Deadline => 24ms;
			Period => 24ms;
			Priority => 3;
	end ref_ctrl.impl;

	thread data_recorder
		features
			data_out: out data port;
			hp_data_in: in data port;
		flows
			F1: flow path hp_data_in -> data_out {latency => 500us .. 500us;};
	end data_recorder;

	thread implementation data_recorder.impl
		flows
			F1: flow path hp_data_in -> data_out {latency => 500us .. 500us;};
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 2ms .. 3ms;
			Deadline => 120ms;
			Period => 120ms;
			Priority => 4;
			dispatch_jitter => 100us; -- release jitter
	end data_recorder.impl;

	thread network_gatekeeper
		features
			isc_data_out: out data port;
			isc_data_in: in data port;
			isc_send_data: out event data port;
			isc_read_data: in event data port;
		flows
			F1: flow path isc_read_data -> isc_data_out {latency => 500us .. 500us;};
			F2: flow path isc_data_in -> isc_send_data;
	end network_gatekeeper;
	
	thread implementation network_gatekeeper.impl
		flows
			F1: flow path isc_read_data -> isc_data_out {latency => 500us .. 500us;};
			F2: flow path isc_data_in -> isc_send_data;
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 500us .. 1ms;
			Deadline => 240ms;
			Period => 240ms;
			Priority => 5;
	end network_gatekeeper.impl;
	
	thread state_machine
		features
			read_state_trans: in data port;
			send_state_trans: out data port;
	end state_machine;

	thread implementation state_machine.impl
		properties
			Dispatch_Protocol => Periodic;
			Compute_Execution_Time => 300us .. 500us;
			Deadline => 220ms;
			Period => 220ms;
			Priority => 6;
	end state_machine.impl;

end EstimateAndCtrl;